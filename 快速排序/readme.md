# 快速排序
> SortDemo.cpp为c语言版本，demo.java为网上流传的版本，demo2.java为我自己想的通过java实现类似c语言指针操作方式的版本。

### 思路

选中最左边为基准值（任意值都可作为基准值），指针在最右边。

如果指针所指的值比基准值大，指针前移，否则指针所指向的值填充到空白位置。并且指针跟过去。

指针做完移动后，后移，如果指针所指向的值比基准值小，指针前移，否则指针移到空白位置。并且指针跟过去。





样本数据：

![K9jU3j.png](https://s2.ax1x.com/2019/10/15/K9jU3j.png)

现在，把你的两只手的食指拿出来。左手食指放在4的位置（首端），右手食指放在6的位置（末端）。

心中想着一个基准值：4（我们将第一个数字作为基准值）。

模拟想象这10个数字每个数字占一个坑，坑里放着这个数字。

然后将4从她的坑里拿出来，放到一边。



现在开始：

右手手指指的数字是否比4大？右手向左移动一个位置：将此数字填入左手指向的地方，看左手并将左手向右移动一个位置

左手手指指的数字是否比4小？左手向右移动一个位置：将此数字填入右手指向的地方，看右手并将右手向左移动一个位置

（上述是移动规律的三目运算符）



【简单说就是，看右手，当右手遇到比基准值小的数字时，将此数字给左手指的地方。然后开始看左手，当左手遇到比基准值大的数字时，将此数字给右手指的地方。然后开始看右手...】





### 操作实例

例如：

右手指向6，是否比4大？是，结果是右手向左移动一个位置。右手指向2：

|      | 8    | 9    | 5    | 0    | 1    | 3    | 7    | 2    | 6    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 左手 |      |      |      |      |      |      |      | 右手 |      |

右手指向2，是否比4大？否，结果是将2放到左手指向的地方，**看左手**并将左手向右移动一个位置：

| 2    | 8    | 9    | 5    | 0    | 1    | 3    | 7    |      | 6    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      | 左手 |      |      |      |      |      |      | 右手 |      |

左手指向8，是否比4大？是，结果是将8放到右手指向的地方，**看右手**并将右手向左移动一个位置：

| 2    |      | 9    | 5    | 0    | 1    | 3    | 7    | 8    | 6    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      | 左手 |      |      |      |      |      | 右手 |      |      |

右手指向7，是否比4大？是，结果是右手向左移动一个位置。右手指向3：

| 2    |      | 9    | 5    | 0    | 1    | 3    | 7    | 8    | 6    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      | 左手 |      |      |      |      | 右手 |      |      |      |

右手指向3，是否比4大？否，结果是将3放到左手指向的地方，**看左手**并将左手向右移动一个位置：

| 2    | 3    | 9    | 5    | 0    | 1    |      | 7    | 8    | 6    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      | 左手 |      |      |      | 右手 |      |      |      |

左手指向9，是否比4大？是，结果是将9放到右手指向的地方，**看右手**并将右手向左移动一个位置：

| 2    | 3    |      | 5    | 0    | 1    | 9    | 7    | 8    | 6    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      | 左手 |      |      | 右手 |      |      |      |      |

右手指向1，是否比4大？否，结果是将1放到左手指向的地方，**看左手**并将左手向右移动一个位置：

| 2    | 3    | 1    | 5    | 0    |      | 9    | 7    | 8    | 6    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      | 左手 |      | 右手 |      |      |      |      |

左手指向5，是否比4大？是，结果是将5放到右手指向的地方，**看右手**并将右手向左移动一个位置：

| 2    | 3    | 1    |      | 0    | 5    | 9    | 7    | 8    | 6    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      | 左手 | 右手 |      |      |      |      |      |

右手指向0，是否比4大？否，结果是将0放到左手指向的地方，**看左手**并将左手向右移动一个位置：

| 2    | 3    | 1    | 0    |            | 5    | 9    | 7    | 8    | 6    |
| ---- | ---- | ---- | ---- | ---------- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      | 左手  右手 |      |      |      |      |      |

左手右手指向同一个地方，第一轮结束。

我们将基准值4，放入空白地方。

（思考，4拿不拿出是没有关系的，只是4作为基准值，如果放在里面一直移动，会影响理解，所以我们在最后，一轮移动完成时，才把基准值4放到它的位置。）

此时基准值4，左边的所有数字，都比它小，右边的所有数字，都比它大。



然后我们递归移动4左边的，4右边的。

| 2    | 3    | 1    | 0    |
| ---- | ---- | ---- | ---- |
|      |      |      |      |

| 5    | 9    | 7    | 8    | 6    |
| ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |



**最后递归完成即可完成排序。**



#### 问题处理

上述排序中，有一个问题，就是**和基准值相等**的情况没有处理。我们可以随便做处理，将**和基准值相等的数**看作比基准值大，或者比基准值小。放到相关情况中处理。



### 完整代码

C代码：

```c
#include <stdio.h>

int* hqsort(int* arr, int start, int end);
void swap(int& i, int& j);//交换两个数
void printArr(int* arr,int n);


int main(void)
{
	//int arr[] = { 4,8,9,5,0,1,3,7,2,6 };
	//int arr[] = {3, 3, 3, 7, 9, 122344, 4656, 34, 34, 4656, 5, 6, 7, 8, 9, 343, 57765, 23, 12321};
	//int arr[] = {5,1,8,3,0,6,2,9,2,7,8,4,2,1,9,5,3};
	int arr[] = { 5,1,4,2,8,5,3,2 };
	
	int n = sizeof(arr) / sizeof(arr[0]);
	printf("数组大小：%d\n", n);


	//测试交换两数
	/*int i = 2, j = 3;
	swap(i, j);
	printf("i:%d   j:%d\n", i, j);*/

	//测试*q > markNum
	/*int* h = arr + (9 - 0);
	if (*h > 3)
		printf("√");*/

	//测试q--
	/*int* h = arr + 9;
	h--;
	printf("%d",*h);*/


	hqsort(arr,0,n-1);//索引值：长度-1

	printf("排序后:\n");
	printArr(arr,n);


	printf("\n\n\n\n\n");
}

int* hqsort(int* arr, int start, int end)//数组头指针，开始坐标，结束坐标
{
	int* q;
	int markNum = arr[start];
	int i=start, j=end;
	int num = 0;
	//q = arr + (end-start); //并非之差，而是永远都是移到最后。
	q = arr + end;


	while (i < j)
	{
		//num++;//比放后面少了一个++ 并没有。。
		if (num % 2 == 0)
		{
			while (i<j && *q >= markNum)//处理与基准值相等的数
			{
				j--;
				q--;
			}
			if (i < j)//当两个移到一处时，就不需处理
			{
				//交换*q与arr[i]的值
				swap(*q, arr[i]);
				//转移指针
				q = &arr[i];
			}
		}
		else
		{
			while (i < j && *q < markNum)
			{
				i++;
				q++;
			}
			if (i < j)
			{
				swap(*q, arr[j]);
				q = &arr[j];
			}
		}
		num++; //num需初始化为0
	}
	//printf("num:%d\n", num);
	//printArr(arr,n);//查看每次递归排序的结果


	//判断是否有序，最终
	
	//假设不是最终，排左，排右
	//i-1是基准值所在坐标左一点，排左(或右)的前提是，至少要有两个值才能排，所以必须要i-start>1。前闭后闭，
	if(i - start > 1)
		hqsort(arr, start, i-1);
	//j+1是基准值所在坐标右一点
	if(end - j > 1)
		hqsort(arr, j + 1, end);


	
	return arr;

}

void swap(int& i, int& j)
{
	//一个数异或同一个数两次等于它本身
	i = i ^ j;
	j = i ^ j;//i^j^j = i
	i = i ^ j;//i^j^i = j

	/*int t;
	t = i;
	i = j;
	j = t;*/
}

void printArr(int* arr,int n)
{
	
	for (int i = 0; i < n; i++)
		printf("%d ", arr[i]);
	printf("\n");
	printf("\n");
}
```





### 简洁代码

```c
#include <stdio.h>

int* hqsort(int* arr, int start, int end);
void swap(int& i, int& j);//交换两个数
void printArr(int* arr,int n);


int main(void)
{
	//int arr[] = { 4,8,9,5,0,1,3,7,2,6 };
	//int arr[] = {3, 3, 3, 7, 9, 122344, 4656, 34, 34, 4656, 5, 6, 7, 8, 9, 343, 57765, 23, 12321};
	//int arr[] = {5,1,8,3,0,6,2,9,2,7,8,4,2,1,9,5,3};
	int arr[] = { 5,1,4,2,8,5,3,2 };
	
	int n = sizeof(arr) / sizeof(arr[0]);
	printf("数组大小：%d\n", n);


	hqsort(arr,0,n-1);//索引值：长度-1

	printf("排序后:\n");
	printArr(arr,n);


	printf("\n\n\n\n\n");
}

int* hqsort(int* arr, int start, int end)//数组头指针，开始坐标，结束坐标
{
	int* q;
	int markNum = arr[start];
	int i=start, j=end;
	int num = 0;
	q = arr + end;


	while (i < j)
	{
		if (num % 2 == 0)
		{
			while (i<j && *q >= markNum)//处理与基准值相等的数
			{
				j--;
				q--;
			}
			if (i < j)//当两个移到一处时，就不需处理
			{
				//交换*q与arr[i]的值
				swap(*q, arr[i]);
				//转移指针
				q = &arr[i];
			}
		}
		else
		{
			while (i < j && *q < markNum)
			{
				i++;
				q++;
			}
			if (i < j)
			{
				swap(*q, arr[j]);
				q = &arr[j];
			}
		}
		num++;
	}

	//printArr(arr,n);//查看每次递归排序的结果


	//判断是否有序，最终
	//i-1是基准值所在坐标左一点，排左(或右)的前提是，至少要有两个值才能排，所以必须要i-start>1。前闭后闭，
	if(i - start > 1)
		hqsort(arr, start, i-1);
	//j+1是基准值所在坐标右一点
	if(end - j > 1)
		hqsort(arr, j + 1, end);


	
	return arr;

}

void swap(int& i, int& j)
{
	//一个数异或同一个数两次等于它本身
	i = i ^ j;
	j = i ^ j;//i^j^j = i
	i = i ^ j;//i^j^i = j
}

void printArr(int* arr,int n)
{
	
	for (int i = 0; i < n; i++)
		printf("%d ", arr[i]);
	printf("\n");
	printf("\n");
}
```



### 注意事项

首次传入的start end（传入的是索引值，首尾部的索引值），首部索引值是0，尾部索引值**end是长度-1**.

不要忘记，**处理相等情况**。
